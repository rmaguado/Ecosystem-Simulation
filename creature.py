"""
Creature Class
"""
from random import randint, uniform, shuffle, seed
from params import Params
from agent import Agent

class Creature():
    """
    Creature Class
    ** check is arguments pos_x ... are realy needed
    """
    def __init__(self, autogenerated, entity_grid, pos_x=None, pos_y=None, strength=None, energy=None, creature_id=None, general_nn=None, inherit_nn=None):
        self.params = Params()
        if self.params.seed:
            seed(self.params.seed)
        self.life_time = 1

        self.pos_x = pos_x
        self.pos_y = pos_y

        self.strength = strength
        self.energy = energy
        self.creature_id = creature_id

        self.inherit_nn = inherit_nn
        self.neural_net = general_nn

        if autogenerated:
            self.spawn_random(entity_grid)

    def spawn_random(self, entity_grid):
        """
        Find an empty location to spawn in.
        Assigns random id and strength values.
        """
        # if not receiving a neural net, creates one
        if not self.neural_net:
            #Â if inhering a neural network, copies its weights
            if self.inherit_nn:
                self.neural_net.inherit_network(self.inherit_nn.get_weights())
            # otherwise create a new network
            else:
                self.neural_net = Agent()
        # searches for an empty spot to spawn in
        if not self.pos_x and not self.pos_y:
            empty = False
            while not empty:
                self.pos_x = randint(0, self.params.grid_size-1)
                self.pos_y = randint(0, self.params.grid_size-1)
                if entity_grid[self.pos_x][self.pos_y][0] == 0:
                    empty = True

        if not self.creature_id:
            self.creature_id = uniform(0.01, 0.99) # avoid zero
        if not self.strength:
            self.strength = uniform(0.01, 0.99)
        if not self.energy:
            self.energy = self.get_reproductive_cost()
                        # (strength * 100) + 5 : min 3 avg 27.5 max 52.5

    def inherit(self, parent, entity_grid, general_nn=None):
        """
        Attempts to spawn the new creature after reproduction.
        Look for an empty location around the parent.
        Then copies the neural net.
        Modifies id and strength values.
        """
        spawn_x = [-1, 0, 1, 1, 1, 0, -1, -1]
        spawn_y = [1, 1, 1, 0, -1, -1, -1, 0]
        pos = [0, 1, 2, 3, 4, 5, 6, 7]
        shuffle(pos) # permutes pos in place
        success = False
        for i in pos:
            # find random empty spot next to parent
            if (parent.pos_x + spawn_x[i] >= 0 and parent.pos_x + spawn_x[i] < self.params.grid_size and
                    parent.pos_y + spawn_y[i] >= 0 and parent.pos_y + spawn_y[i] < self.params.grid_size and
                    entity_grid[parent.pos_x + spawn_x[i]][parent.pos_y + spawn_y[i]][0] == 0):
                self.pos_x = parent.pos_x + spawn_x[i]
                self.pos_y = parent.pos_y + spawn_y[i]
                success = True
                break
        if success: # child properties similar to parent
            if general_nn:  # interit NN
                self.neural_net = general_nn
            else:
                self.neural_net = Agent()
                self.neural_net.inherit_network(parent.neural_net.get_weights())
            self.creature_id = self.value_shift(parent.creature_id)
            self.strength = self.value_shift(parent.strength)
            self.energy = parent.get_reproductive_cost() * self.params.energy_reprod_transfer_rate

        return success # may be no space to spawn !

    def value_shift(self, value):
        """
        Slightly modifies a value.
        """
        new_value = 1
        while new_value >= 1: # wwant < 1
            new_value = value * uniform(1-self.params.relatedness, 1+self.params.relatedness)

        return new_value

    def get_action(self, state):
        """
        Call for a q-table prediction from the neural network.
        """
        q_table = self.neural_net.act(state)

        return q_table

    def store_experience(self, state, action, reward, future_state):
        """
        Stores rewards and states for the neural network to experience recall.
        """
        return self.neural_net.store(state, action, reward, future_state)

    def get_reproductive_cost(self):
        """
        Calculate the cost of reproducing based on strength.
        """
        return self.params.reproductive_cost(self.strength)

    def check_living(self):
        """
        Check if creature has run out of energy.
        """
        return self.energy > 0

    def check_related(self, creature):
        """
        Check if two creatures share a similar id.
        """
        difference = abs(self.creature_id - creature.creature_id)

        return difference < self.params.relatedness * self.params.relatedness_rate
