"""
Entities Class
"""
import time
from random import randint
import numpy as np
from params import Params
from creature import Creature

class Entities():
    """
    Entities Class
    """
    def __init__(self, environment, general_nn=None, inherit_nn=None):
        self.params = Params()
        self.creatures = []
        self.entity_grid = np.zeros((self.params.grid_size, self.params.grid_size, 4)) # 4 is for has_entity, id, strength, energy
        self.environment = environment
        if self.params.general_nn:
            self.random_policy = True
        else:
            self.random_policy = False

        self.general_nn = general_nn
        self.inherit_nn = inherit_nn

        for _ in range(self.params.starting_creatures):
            self.spawn_creature()

        self.date_time = time.strftime("%Y.%m.%d-%H.%M.%S")
        if self.params.verbose:
            line = "creature     strength  pos_x  pos_y       left        up     right      down       eat     repro  action  reward\n"
            with open(f"out/log_out-{self.date_time}.txt", "w") as fname:
                fname.write(line)

    def write_creature(self, creature):
        """
        Write in creature traits in grid.
        """
        self.entity_grid[creature.pos_x][creature.pos_y][0] = 1
        self.entity_grid[creature.pos_x][creature.pos_y][1] = creature.creature_id
        self.entity_grid[creature.pos_x][creature.pos_y][2] = creature.strength
        self.entity_grid[creature.pos_x][creature.pos_y][3] = 1 / creature.energy

    def erase_creature(self, creature):
        """
        Clear the location of a creature in the grid.
        """
        self.entity_grid[creature.pos_x][creature.pos_y][:] = 0

    def spawn_creature(self, pos_x=None, pos_y=None, strength=None, creature_id=None, energy=None):
        """
        Create creature objects.
        """
        if self.general_nn:
            creature = Creature(autogenerated=True, entity_grid=self.entity_grid, pos_x=pos_x, pos_y=pos_y, strength=strength, energy=energy, creature_id=creature_id, general_nn=self.general_nn)
        elif self.inherit_nn:
            creature = Creature(autogenerated=True, entity_grid=self.entity_grid, pos_x=pos_x, pos_y=pos_y, strength=strength, energy=energy, creature_id=creature_id, inherit_nn=self.general_nn)
        else:
            creature = Creature(autogenerated=True, entity_grid=self.entity_grid, pos_x=pos_x, pos_y=pos_y, strength=strength, energy=energy, creature_id=creature_id)
        self.write_creature(creature)
        self.creatures.append(creature)

    def get_creature(self, creature_id):
        """
        Obtain creature object from id.
        """
        creature = None
        for i in self.creatures:
            if i.creature_id == creature_id:
                creature = i
                break

        return creature

    def clear(self):
        """
        Empty creature objects from queue.
        """
        for creature in self.creatures:
            self.entity_grid[creature.pos_x][creature.pos_y][:] = 0
        self.creatures = []

    def get_state(self, var_x, var_y):
        """
        Returns input grid for a 5 x 5 grid.
        """
        state = np.ndarray((5, 5, 4))
        state[:, :, 0] = np.pad(self.environment.grass, ((2, 2), (2, 2)), 'constant', constant_values=(1, 1))[var_x:var_x+5, var_y:var_y+5]
        state[:, :, 1:] = np.pad(self.entity_grid, ((2, 2), (2, 2), (0, 0)), 'constant', constant_values=(1, 1))[var_x:var_x+5, var_y:var_y+5, 1:]
        state = state.reshape((1, 5, 5, 4))

        return state

    def iterate(self):
        """
        Each creature takes a turn.
        """
        logs = []
        terminated = []
        for i in self.creatures:
            log, term = self.action(i)
            logs.append(log)
            if term:
                terminated.append(i)
        for i in terminated:
            self.delete_creature(i)

        return logs

    def action(self, creature):
        """
        Get an action from the Neural Net,
        Call the function,
        Store the rewards and states.
        """
        state = self.get_state(creature.pos_x, creature.pos_y)
        q_table = creature.get_action(state)
        if np.random.rand() < self.params.exploration_rate or self.random_policy:
            action = randint(0, self.params.action_size-1)
        else:
            action = np.argmax(q_table)

        reward = None
        log = None
        terminated = None
        if action == 0:     # left
            reward, log, terminated = self.move_creature(creature, -1, 0)
        elif action == 1:   # up
            reward, log, terminated = self.move_creature(creature, 0, 1)
        elif action == 2:   # right
            reward, log, terminated = self.move_creature(creature, 1, 0)
        elif action == 3:   # down
            reward, log, terminated = self.move_creature(creature, 0, -1)
        elif action == 4:   # eat
            reward, log, terminated = self.eat_grass(creature)
        elif action == 5:   # reproduce
            reward, log, terminated = self.reproduce_creature(creature)

        if self.check_death(creature):
            reward = -50
        update_policy = creature.get_rewards(state, action, reward, self.get_state(creature.pos_x, creature.pos_y))
        if update_policy:
            self.random_policy = True
            if self.params.verbose:
                print(f"Randomness policy has been updated for: {creature.creature_id}")

        if self.params.verbose:
            actions = ['left ', 'up   ', 'right', 'down ', 'eat  ', 'repro']
            np.set_printoptions(precision=6, suppress=True, linewidth=500, sign=' ')
            line = f"{creature.creature_id:12.10f} {creature.strength:8.4}  {creature.pos_x:5}  {creature.pos_y:5}  " + np.array2string(q_table)[2:-2] +f"  {actions[action]}   {reward}\n"
            with open(f"out/log_out-{self.date_time}.txt", "a") as fname:
                fname.write(line)

        return log, terminated

    def danger_evasion(self, creature, x_change, y_change):
        """
        Determines if a creature's action is putting if away from danger or towards it.
        """
        state = self.get_state(creature.pos_x, creature.pos_y)
        reward = None
        nearest_x = None
        nearest_y = None
        reward = 0
        for var_x, var_y in [[0, 1], [1, 0], [0, -1], [-1, 0]]:
            competitor = self.get_creature(state[0][var_x + 2][var_y + 2][1])
            if competitor:
                if competitor.strength > creature.strength:
                    nearest_x = var_x
                    nearest_y = var_y
                    break
        if nearest_x:
            if nearest_x == x_change and nearest_y == y_change:
                reward = -50

        return reward

    def check_death(self, creature):
        """
        Determines if a creature's is in direct danger of being eaten.
        """
        state = self.get_state(creature.pos_x, creature.pos_y)
        for var_x, var_y in [[0, 1], [1, 0], [0, -1], [-1, 0]]:
            competitor = self.get_creature(state[0][var_x + 2][var_y + 2][1])
            if competitor:
                if competitor.strength > creature.strength:
                    return True
        return False

    def move_creature(self, creature, x_change, y_change):
        """
        Calls to move the creature in a direction.
        If the creature does not have enough energy or cannot move: the creature will not move.
        If the creature moves into an empty space, the old location is wiped and is written in the new location.
        If the creature moves into another creature, the one with a greater strength will consume the other and take a portion of its energy.
        """
        reward = None
        log = None
        terminated = False
        # Check that the creature will not move outside the grid bounds and has enough energy to move.
        if creature.pos_x + x_change >= 0 and creature.pos_x + x_change < self.params.grid_size and creature.pos_y + y_change >= 0 and creature.pos_y + y_change < self.params.grid_size and creature.energy > 1:
            # check if the new location is empty
            if self.entity_grid[creature.pos_x + x_change][creature.pos_y + y_change][0] == 0:
                reward = 0 # self.danger_evasion(creature, x_change, y_change)
                self.erase_creature(creature)
                creature.pos_x += x_change
                creature.pos_y += y_change
                creature.energy -= 2
                # if creature has run out of energy it dies
                if creature.check_living():
                    self.write_creature(creature)
                    # reward creature based on moving away from danger
                    log = f"{creature.creature_id} moved to {creature.pos_x}, {creature.pos_y}"
                else:
                    terminated = True
                    reward = -50
                    log = f"{creature.creature_id} starved to death"
            # is not empty
            else:
                # gets creature object for competing creature
                competitor = self.get_creature(self.entity_grid[creature.pos_x + x_change][creature.pos_y + y_change][1])
                # checks strength, stronger creature survives and consumes other
                if creature.strength > competitor.strength:
                    self.erase_creature(creature)
                    creature.energy -= 2
                    creature.energy += competitor.energy
                    creature.pos_x += x_change
                    creature.pos_y += y_change
                    # if creature has run out of energy it dies (energy from competitor might not outweigh movement cost)
                    if creature.check_living():
                        self.write_creature(creature)
                        # check if creatures were related (anti-cannibalism rewarding)
                        if creature.check_related(competitor):
                            reward = -50
                        else:
                            reward = 0 # competitor.energy
                        log = f"{creature.creature_id} moved to {creature.pos_x}, {creature.pos_y} and consumed {competitor.creature_id}"
                    else:
                        terminated = True
                        reward = -50
                        log = f"{creature.creature_id} moved to {creature.pos_x}, {creature.pos_y} and consumed {competitor.creature_id} but still starved to death"

                    if not self.params.simulate:
                        self.delete_creature(competitor)
                # if competitor is stronger
                else:
                    competitor.energy += int(creature.energy / 2)
                    self.erase_creature(creature)
                    log = f"{creature.creature_id} was consumed by {competitor.creature_id}"
                    reward = -50
                    terminated = True
        # creature tries to move outside grid
        else:
            creature.energy -= 1
            # if creature has run out of energy it dies
            if creature.check_living():
                self.write_creature(creature)
                reward = 0
                log = f"{creature.creature_id} failed to move"
            else:
                self.erase_creature(creature)
                terminated = True
                reward = -50
                log = f"{creature.creature_id} starved to death"

        return reward, log, terminated

    def eat_grass(self, creature):
        """
        Function for creature to consume grass.
        """
        terminated = False
        # check if grass has is green
        if self.environment.grass[creature.pos_x][creature.pos_y] == 1:
            self.environment.grass[creature.pos_x][creature.pos_y] = 0
            creature.energy += 3
            self.write_creature(creature)
            reward = 0
            log = f"{creature.creature_id} consumed grass at {creature.pos_x}, {creature.pos_y}"
        # grass has not grown yet
        else:
            creature.energy -= 1
            # if creature has run out of energy it dies
            if creature.check_living():
                self.write_creature(creature)
                reward = 0
                log = f"{creature.creature_id} failed to consume grass"
            else:
                self.erase_creature(creature)
                terminated = True
                reward = -50
                log = f"{creature.creature_id} starved to death"

        return reward, log, terminated

    def reproduce_creature(self, parent):
        """
        Attempts to create a new creature given space and energy requirements are met.
        """
        terminated = False
        creature = Creature(autogenerated=False, entity_grid=self.entity_grid, general_nn=self.general_nn)
        # reproduction success based on space and energy
        success = creature.inherit(parent, self.entity_grid) and parent.energy > parent.get_reproductive_cost()
        if success:
            self.creatures.append(creature)
            self.write_creature(creature)
            parent.energy -= parent.get_reproductive_cost()
            self.write_creature(parent)
            reward = 100
            log = f"{parent.creature_id} reproduced at {parent.pos_x}, {parent.pos_y}"
        else:
            parent.energy -= 1
            # if creature has run out of energy it dies
            if parent.check_living():
                self.write_creature(parent)
                reward = 0
                log = f"{parent.creature_id} failed to reproduce"
            else:
                self.erase_creature(parent)
                terminated = True
                reward = -50
                log = f"{parent.creature_id} starved to death"

        return reward, log, terminated

    def delete_creature(self, creature):
        """
        Deletes a creature from the grid and creature list.
        """
        self.entity_grid[creature.pos_x][creature.pos_y][:] = 0
        self.creatures.remove(creature)
